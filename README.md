# Решение
В данном решении было решено использовать следующий подход:
- База данных как хранилище: так как данную функцию будут использовать разные инстансы приложения, данные о флуде должны быть централизованы
- Транзакция для изменения данных: транзакция необходима потому, что на момент её начала у неё будет снапшот данных уже подтверждённых транзакций и случившихся сообщений. Так мы избежим ситуации, в которой мы начали делать INSERT в момент, когда флуд ещё не случился, а закончили уже тогда, когда он начался. SELECT делается частью транзакции по той же причине. Это приведёт к тому, что сообщение о флуде вернёт тот инстанс приложения, который на самом деле превысил порог вызовов, а значит мы точнее сможем отследить момент, в который это случилось.
- Использование контекста: для надёжности работы приложения в функцию, выполняющую запрос в БД, передаётся контекст с таймаутом. Предположительно, если запрос не отработает за заданное время, то это будет означать перегрузку БД -> произошедший флуд (время задано чуть больше для затрат на установление соединения)





Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.
